---
layout: post
title: Advanced Guide to Git
banner-img: img/blog-git.png
excerpt: "As a modern software engineer, you probably have a good grasp of
the fundamentals of Git, but there's actually a surprising
amount more to it than you might think..."
---
<!-- Article -->
<article>
    <div class="row">
        <div class="offset-md-2 col-md-8" id="description">

            <p>
                As a modern software engineer, you probably have a good grasp of
                the fundamentals of Git, but there's actually a surprising
                amount more to it than you might think. So much so, that in fact
                it might challenge the way you think of Git. For one thing, your
                commit history is much more fluid than you might
                assume&mdash;it's not as in stone as you're let to believe early
                on. This guide is about unlocking the hidden powers of Git to
                take your version control to the next level. As such, it assumes
                you already have a good grasp of the basics of committing,
                branching, and merging.
            </p>

            <h4>Remotes</h4>
            <p>
                You probably read about the distributed nature of Git at some
                point, but have you ever actually experienced it? It's good to
                know how to handle origins flexibly in case you ever run into a
                situation where you really need it. For example, in case your
                Git server might down for an extended period of time, or you
                need to collaborate in a place without Internet access.
            </p>
            <p>
                If you need to, you can clone from a peer machine on the network
                using clone over SSH using <code>git clone
                ssh:gituser@hostname:/path/to/project</code>. Then ask the owner
                of the peer machine to enter their password&mdash;or
                alternatively, ask them to set up a new user on their machine as
                a temporary origin with a shared password&mdash;and you're good
                to go! Push and pull like normal.
            </p>
            <p>
                Alternatively, you may run into a situation where code is being
                developed on a machine which doesn't have access to your Git
                server. Perhaps a contractor who doesn't have yet have building
                network access or a lab machine that doesn't connect to the main
                network. In this case, you would add the access-less machine as
                another remote of your project on your machine using <code>git
                remote add labmachine
                git@gitserver.com:path/to/project.git</code>. Check to make sure
                it got added correctly with <code>git remote -vv</code>. Now you
                can simply <code>git pull labmachine master</code> and
                <code>git push origin master</code> whenever you need to check
                in the code from the lab machine's to the other network.
            </p>

            <h4>Branching</h4>
            <p>
                As a mindful developer you should strive to keep your Git
                history just as clean as your code. There's a variety of
                techniques you can use, but be forewarned &mdash;some of them
                sound like heresey initially because they result in altered Git
                history. If you bear with me you'll find it can actually result
                in a cleaner code base and fewer errors.
            </p>
            <p>
                Also, as a general rule, if you do choose to alter your Git
                history, <strong>do not ever use</strong>
            </p>

{% highlight sh %}
git push --force # Don't do this. You'll lose friends.
{% endhighlight %}

            <p>
                to push your changes to the remote when collaborating. This will
                overwrite commits on the remote branch and could lead to
                unintentionally destroying someone else's work. The easiest way
                around this is to work locally on a branch that only you
                own&mdash;that way you're free to muck around all you want with
                its history. If you prefer to push or are collaborating with
                others, the other option is to wait until you're about to merge
                your topic branch into dev/master <strong>and</strong> the topic
                branch will be deleted after the merge. Alter the topic branch's
                history locally, perform the merge, and then delete the topic
                branch. Booyah, no inconsistent timelines to confuse your
                coworkers.
            </p>

            <h5>Moving Commits</h5>
            <p>
                Has it ever happened to you that you've committed to the wrong
                branch? It's okay, it happens to the best of us! Just don't
                <code>git push</code> yet. Checkout the branch you meant to
                commit on, then run
            </p>

{% highlight sh %}
git cherry-pick <commit-hash>
{% endhighlight %}

            <p>
                to copy over the accidental commit to this
                branch. Now go back to the other branch and run
            </p>

{% highlight sh %}
git reset --hard <commit-hash>
{% endhighlight %}

            <p>
                with the hash of the last commit that should be on that branch.
                Now you can push your commit to the correct branch. Phew, no
                problem. Cherry-pick can help you out of tight spots, but be
                careful not to abuse it.
            </p>
        </div>
    </div>

    {% include image.html path="img/blog-git-cherrypick.png" width="8" caption="Git cherry-pick can help you out of tight spots." %}

    <div class="row">
        <div class="offset-md-2 col-md-8">
            <h5>Stashing</h5>
            <p>
                You might already know this one, but Git's stash is incredibly
                helpful. It's used to save uncommitted changes without
                committing to be applied later, even in a different branch. For
                example, if you're trying to <code>git pull</code> but you have
                a possibly conflicting change that's preventing Git from
                pulling, <code>git stash</code> your changes so you can pull,
                then run <code>git stash pop</code> or <code>git stash
                apply</code> (pop also deletes the stash unless it causes a
                merge conflict). Now you can properly deal with merge conflicts
                if there are any.
            </p>
            <p>
                You can have multiple stashed changes. Run <code>git stash
                list</code> to see them all and <code>git stash show -p
                stash@{id}</code> to view the stash in diff form, replacing 'id'
                with the ID of the stash you want.
                <code>git stash drop stash{id}</code> is used to delete a stash.
                It's very helpful when you have uncommitted changes preventing
                you from checking out another branch, etc. Use <code>git stash
                clear</code> to delete all stashes.
            </p>
            <p>
                All of these commands can be run without a stash ID&mdash;the
                action will simply apply to the topmost stash
                (<code>stash@{0}</code>). To keep your stashes from getting out
                of control, you should attach memorable messages when stashing.
                Use
            </p>

{% highlight sh %}
git stash save "My memorable message"
{% endhighlight %}

            <h5>Patches</h5>
            <p>
                Sometimes you need to move code around but can't or don't want
                to push it to a remote. Maybe it's test code that your colleague
                wants to help you debug, and you'd rather not push it. In this
                case, you can write your changes into a patch, which is just a
                file containing the diff. Simply run
            </p>

{% highlight sh %}
git diff > mypatch.patch
{% endhighlight %}

            <p>
                and your diff will be saved into the file. Send it to your
                colleague, and let them apply it to their copy of the project
                with
            </p>

{% highlight sh %}
git apply mypatch.patch
{% endhighlight %}

            <h5>Rebase</h5>
            <p>
                Finally, one of the most powerful tools in Git is called rebase.
                It has two main uses&mdash;rebasing on top of another branch and
                interactive rebase, which is the one that allows rearranging
                history.
            </p>
            <p>
                Say you've been working locally on an unpushed local branch
                called topic, which initially branched from master. You see some
                new commits appear on master that are useful to you. At this
                point, you have two options&mdash;you could merge master into
                your branch, but if you have to do this often your branch's
                history will become polluted and hard to read. However, in this
                case because your branch is unpushed, you have another option,
                which is rebasing (yes, it does exactly what it sounds like).
                Once you've fetched the new commits on master, simply run
            </p>

{% highlight sh %}
git rebase master
{% endhighlight %}

            <p>
                and voila! Your commits are now on top of master. If you
                encounter a conflict, don't fret; just resolve it like you would
                for a merge, then run <code>git rebase --continue</code> (Git
                will prompt you). Now your branch history stays clean, you'll be
                able to trace commit history more easily across the project, and
                you'll be guaranteed to have a clean fast-forward when you merge
                back into master. As an added benefit, the commits related to
                your feature will stay together as a group instead of
                interspersed with others in master.
            </p>
        </div>
    </div>

    <!-- Image -->
    {% include image.html path="img/blog-git-rebase.png" width="8" caption="Git rebase can be used instead of merge." %}

    <div class="row">
        <div class="offset-md-2 col-md-8">
            <p>
                As an aside, if you're working on a branch and have some
                unpushed commits, you can pull with <code>git pull
                --rebase</code> to keep your commits on top of whatever other
                commits are being made on your branch.
            </p>
            <p>
                The other rebase, interactive rebase, is an interesting feature
                that comes with great power/responsibility. Imagine that you've
                been working again on a branch called topic. You've been
                diligently marking commits with WIP to signify that they don't
                build, and you're getting ready to merge back to master soon.
                Now, you might realize that you'll never encounter a situation
                where you want someone to checkout one of the WIP commits
                anyway, so why not merge them with other commits. Now, if all
                your commits are unpushed, you can clean up your commits as you
                go without messing up anyone's history. Otherwise, you should
                only perform the interactive rebase when you're about to merge
                back to master <em>and you'll be deleting the topic branch
                after</em>. Run
            </p>

{% highlight sh %}
git rebase -i HEAD~<num>
{% endhighlight %}

            <p>
                replacing num with the number of commits you want to rearrange.
                You'll enter the interactive rebase interface. You'll have
                instructions there, but in this interface you would type
                <code>squash</code> next to all your WIP commits to combine them
                with their downstream commits. You'll have an opportunity later
                to assign new commit messages to these squashed commits. You can
                also rearrange and delete commits in this interface, but be
                careful not to lose any work. And that's it! You've successfully
                changed your Git history. Again, do not use <code>git push
                --force</code> when collaborating because you risk undoing
                someone else's work.
            </p>

            <h5>Conclusion</h5>
            <p>
                I hope that these techniques, whether they were life-changing or
                not, will help you develop better than ever before. For a more
                thorough guide, I'd encourage you to check out <a
                href="https://git-scm.com/book/en/v2">Pro Git</a>. Like I
                mentioned previously, I believe a great developer should
                maintain their version history just as fastidiously as their
                code. Not only does a clean history help out your teammates, but
                it also helps you when bug-hunting (and/or <code>git
                bisect</code>ing, check that one out). Try out the commands in a
                test project to get used to them and you'll reap the rewards.
                Now git outta here!
            </p>

        </div>
    </div>
</article>
